<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>D&D map</title>
</head>

<style>
    html,
    body {
        height: 100%;
        width: 100%;
        margin: 0;
        overflow: hidden;
        background-color: black;
    }
</style>

<body>
    <canvas id="canvas"></canvas>
    <script src='https://cdn.scaledrone.com/scaledrone-lite.min.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/simple-peer/9.3.0/simplepeer.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.7.3/localforage.nopromises.min.js"></script>
    <script>
        function transformToArray(transform) {
            return [transform.a, transform.b, transform.c, transform.d, transform.e, transform.f]
        }

        const id = window.location.hash.split("#")[1];

        Promise.all([
            localforage.getItem(`image.${id}`),
            localforage.getItem(`fow.${id}`),
            localforage.getItem(`config.${id}`),
        ]).then(([imageDataUrl, fow, config]) => {
            const drone = new Scaledrone('IN4foXiellAoPcJn');
            const room = drone.subscribe(id);
            const outgoing = {};

            room.on('open', error => {
                if (error) {
                    return console.error(error);
                }

                console.debug("Connected to signal room");

                drone.publish({
                    room: id,
                    message: {
                        id: id,
                        channel: "broadcast",
                    }
                });
            });

            const messageHandlers = {
                reqstream: msg => {
                    if (!outgoing[msg.id]) {
                        outgoing[msg.id] = new SimplePeer({
                            initiator: true,
                            config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }
                        });

                        outgoing[msg.id].on('signal', signal => {
                            drone.publish({
                                room: id,
                                message: {
                                    id: id,
                                    to: msg.id,
                                    signal: signal,
                                    channel: "signal",
                                }
                            });
                        });

                        outgoing[msg.id].on('data', () => {
                            // Force frame to clients
                            draw();
                        });

                        outgoing[msg.id].on('connect', () => {
                            outgoing[msg.id].addStream(stream);
                        });

                        outgoing[msg.id].on('close', () => {
                            outgoing[msg.id].destroy();
                            delete outgoing[msg.id];
                        });

                        outgoing[msg.id].on('error', err => {
                            console.error(err);
                        });
                    }
                },
                signal: msg => {
                    if (outgoing[msg.id]) {
                        outgoing[msg.id].signal(msg.signal);
                    }
                },
            }

            room.on('message', message => {
                if (message.data.id != id) {
                    (messageHandlers[message.data.channel] || (() => { }))(message.data);
                }
            });

            class ToolBase {
                constructor(prev_tool, cursor_radius) {
                    this.cursor = {
                        radius: cursor_radius,
                        draw_cursor: !!cursor_radius,
                    };

                    if (prev_tool) {
                        this.last_x = prev_tool.last_x;
                        this.last_y = prev_tool.last_y;
                    } else {
                        this.last_x = canvas.width / 2;
                        this.last_y = canvas.height / 2;
                    }
                }

                on_move(evt) {
                    this.last_x = evt.offsetX || (evt.pageX - canvas.offsetLeft);
                    this.last_y = evt.offsetY || (evt.pageY - canvas.offsetTop);
                }

                on_down(evt) {
                }

                on_up(evt) {
                }

                on_wheel(evt) {
                }
            }

            class DragTool extends ToolBase {
                constructor(...params) {
                    super(...params);

                    this.drag_start = null;
                }

                on_move(evt) {
                    super.on_move(evt);

                    if (this.drag_start) {
                        this.drag_to(ctx.transformedPoint(this.last_x, this.last_y));
                    } else {
                        if (this.cursor.draw_cursor) {
                            draw_local();
                        }
                    }
                }

                on_down(evt) {
                    this.drag_start = ctx.transformedPoint(this.last_x, this.last_y);
                }

                on_up(evt) {
                    this.drag_start = null;
                }
            }

            class MoveTool extends DragTool {
                constructor(prev_tool) {
                    super(prev_tool);

                    canvas.style.cursor = "move";
                }

                drag_to(pt) {
                    onCtx(ctx => ctx.translate(pt.x - this.drag_start.x, pt.y - this.drag_start.y));

                    draw();
                }

                on_wheel(evt) {
                    const scale = Math.pow(scaleFactor, evt.deltaY / -Math.abs(evt.deltaY));
                    const pt = ctx.transformedPoint(this.last_x, this.last_y);

                    onCtx(ctx => {
                        ctx.translate(pt.x, pt.y);

                        ctx.scale(scale, scale);
                        ctx.translate(-pt.x, -pt.y);
                    });

                    draw();

                    return evt.preventDefault();
                }
            }

            class FowTool extends DragTool {
                constructor(prev_tool, erase) {
                    super(prev_tool, config.drawWidth / 2);

                    canvas.style.cursor = "none";

                    this.erase = erase;
                }

                on_wheel(evt) {
                    super.on_wheel(evt);

                    config.drawWidth += evt.deltaY;

                    if (config.drawWidth < 1) {
                        config.drawWidth = 1;
                    }

                    this.cursor.radius = config.drawWidth / 2;

                    draw_local();

                    return evt.preventDefault();
                }

                on_down(evt) {
                    super.on_down(evt);

                    fowCtx.lineWidth = config.drawWidth;
                    fowCtx.lineCap = "round";
                    fowCtx.lineJoin = "round";

                    if (this.erase) {
                        fowCtx.globalCompositeOperation = "destination-out";
                    } else {
                        fowCtx.globalCompositeOperation = "source-over";
                    }

                    const pt = ctx.transformedPoint(this.last_x, this.last_y);

                    fowCtx.beginPath();
                    fowCtx.moveTo((pt.x - imageOffsetX) / imageScale, (pt.y - imageOffsetY) / imageScale);
                }

                on_up(evt) {
                    super.on_up(evt);
                    this.queue = [];

                    const pt = ctx.transformedPoint(this.last_x, this.last_y);
                    fowCtx.lineTo((pt.x - imageOffsetX) / imageScale, (pt.y - imageOffsetY) / imageScale);
                    fowCtx.stroke();

                    draw();
                }

                drag_to(pt) {
                    fowCtx.lineTo((pt.x - imageOffsetX) / imageScale, (pt.y - imageOffsetY) / imageScale);
                    fowCtx.stroke();

                    draw();
                }
            }

            const fowCanvas = document.createElement('canvas');
            const offScreenCanvas = document.createElement('canvas');
            const canvas = document.getElementById('canvas');

            const ctx = canvas.getContext('2d');
            const fowCtx = fowCanvas.getContext('2d');
            const offScreenCtx = offScreenCanvas.getContext('2d');

            const stream = offScreenCanvas.captureStream();

            const scaleFactor = 1.1;

            let imageOffsetX, imageOffsetY, imageScale;

            config = config || {
                drawWidth: 40,
                transform: [1, 0, 0, 1, 0, 0],
            }

            function onCtx(fn) {
                fn(ctx);
                fn(offScreenCtx);
            }

            function draw_local() {
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();

                ctx.drawImage(map_image, imageOffsetX, imageOffsetY, map_image.width * imageScale, map_image.height * imageScale);

                ctx.globalAlpha = 0.5;
                ctx.drawImage(fowCanvas, imageOffsetX, imageOffsetY, map_image.width * imageScale, map_image.height * imageScale);
                ctx.globalAlpha = 1;

                if (tool.cursor.draw_cursor) {
                    ctx.beginPath();

                    const pt = ctx.transformedPoint(tool.last_x, tool.last_y);

                    ctx.lineWidth = 0.4;
                    ctx.strokeStyle = "white";
                    ctx.arc(pt.x, pt.y, (tool.cursor.radius - ctx.lineWidth) * imageScale, 0, Math.PI * 2);

                    ctx.stroke();
                }
            }

            function draw() {
                draw_local();

                offScreenCtx.save();
                offScreenCtx.setTransform(1, 0, 0, 1, 0, 0);
                offScreenCtx.fillRect(0, 0, canvas.width, canvas.height);
                offScreenCtx.restore();

                offScreenCtx.drawImage(map_image, imageOffsetX, imageOffsetY, map_image.width * imageScale, map_image.height * imageScale);
                offScreenCtx.drawImage(fowCanvas, imageOffsetX, imageOffsetY, map_image.width * imageScale, map_image.height * imageScale);
            }

            const map_image = new Image();

            map_image.addEventListener("load", () => {
                console.debug("Setting event handlers.");

                tool = new MoveTool();

                fowCanvas.height = map_image.height;
                fowCanvas.width = map_image.width;

                onCtx(ctx => trackTransforms(ctx));

                fowCtx.fillRect(0, 0, fowCanvas.width, fowCanvas.height);

                resize();
                onCtx(ctx => ctx.setTransform(...config.transform));

                if (fow) {
                    const image = new Image();

                    image.addEventListener('load', () => {
                        fowCtx.clearRect(0, 0, fowCanvas.width, fowCanvas.height);
                        fowCtx.drawImage(image, 0, 0);
                        draw();
                    }, false);

                    image.src = fow;
                }

                function resize() {
                    const transform = ctx.getTransform();

                    canvas.height = window.innerHeight;
                    canvas.width = window.innerWidth;

                    offScreenCanvas.height = window.innerHeight;
                    offScreenCanvas.width = window.innerWidth;

                    imageScale = Math.min(canvas.width / map_image.width, canvas.height / map_image.height);

                    imageOffsetX = (canvas.width / 2) - (map_image.width / 2) * imageScale;
                    imageOffsetY = (canvas.height / 2) - (map_image.height / 2) * imageScale;

                    onCtx(ctx => ctx.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f));
                    draw();
                }

                const saveWorker = new Worker("imageSave.js");

                window.addEventListener('beforeunload', () => {
                    config.transform = transformToArray(ctx.getTransform());

                    saveWorker.postMessage([id, config, fowCanvas.toDataURL()]);
                }, false);

                window.addEventListener('resize', resize, false);

                canvas.addEventListener('wheel', evt => tool.on_wheel(evt), false);
                canvas.addEventListener("mouseup", evt => tool.on_up(evt), false);
                canvas.addEventListener("mousedown", evt => tool.on_down(evt), false);
                canvas.addEventListener("mousemove", evt => tool.on_move(evt), false);

                window.addEventListener("keydown", evt => {
                    switch (evt.which) {
                        case 32:
                            tool = new MoveTool(tool);
                            draw_local();
                            break;
                        case 68:
                            tool = new FowTool(tool, false);
                            draw_local();
                            break;
                        case 83:
                            tool = new FowTool(tool, true);
                            draw_local();
                            break;
                        case 67:
                            const el = document.createElement('textarea');
                            el.value = `https://regiontog.github.io/dmap/client#${id}`;
                            document.body.appendChild(el);
                            el.select();
                            document.execCommand('copy');
                            document.body.removeChild(el);
                            break;
                        case 79:
                            window.open(`https://regiontog.github.io/dmap/client#${id}`)
                            break;
                    }

                }, false);
            });

            map_image.src = imageDataUrl;

            // Adds ctx.getTransform() - returns an SVGMatrix
            // Adds ctx.transformedPoint(x,y) - returns an SVGPoint
            function trackTransforms(ctx) {
                const svg = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
                let xform = svg.createSVGMatrix();
                ctx.getTransform = function () { return xform; };

                const savedTransforms = [];
                const save = ctx.save;
                ctx.save = function () {
                    savedTransforms.push(xform.translate(0, 0));
                    return save.call(ctx);
                };

                const restore = ctx.restore;
                ctx.restore = function () {
                    xform = savedTransforms.pop();
                    return restore.call(ctx);
                };

                const scale = ctx.scale;
                ctx.scale = function (sx, sy) {
                    xform = xform.scaleNonUniform(sx, sy);
                    return scale.call(ctx, sx, sy);
                };

                const rotate = ctx.rotate;
                ctx.rotate = function (radians) {
                    xform = xform.rotate(radians * 180 / Math.PI);
                    return rotate.call(ctx, radians);
                };

                const translate = ctx.translate;
                ctx.translate = function (dx, dy) {
                    xform = xform.translate(dx, dy);
                    return translate.call(ctx, dx, dy);
                };

                const transform = ctx.transform;
                ctx.transform = function (a, b, c, d, e, f) {
                    const m2 = svg.createSVGMatrix();
                    m2.a = a; m2.b = b; m2.c = c; m2.d = d; m2.e = e; m2.f = f;
                    xform = xform.multiply(m2);
                    return transform.call(ctx, a, b, c, d, e, f);
                };

                const setTransform = ctx.setTransform;
                ctx.setTransform = function (a, b, c, d, e, f) {
                    xform.a = a;
                    xform.b = b;
                    xform.c = c;
                    xform.d = d;
                    xform.e = e;
                    xform.f = f;
                    return setTransform.call(ctx, a, b, c, d, e, f);
                };

                const pt = svg.createSVGPoint();
                ctx.transformedPoint = function (x, y) {
                    pt.x = x; pt.y = y;
                    return pt.matrixTransform(xform.inverse());
                }
            }
        }).catch(console.error);
    </script>
</body>

</html>